/* SPDX-License-Identifier: BSD-2-Clause
 * Created: Sun Apr 24 2022 01:13:53 */
#include <sys/cpu.h>
#include <sys/intr.h>
#include <string.h>
#include <sys/kp.h>
#include <x86_64/segment.h>

#define IDT_SIZE 256

#define IDT_TRAP    (15 << 0)
#define IDT_INTR    (14 << 0)
#define IDT_RING_0  ( 0 << 5)
#define IDT_RING_3  ( 3 << 5)
#define IDT_PRESENT ( 1 << 7)

struct idt_entry {
    uint16_t offset_0;
    uint16_t selector;
    uint8_t ist_off;
    uint8_t flags;
    uint16_t offset_1;
    uint32_t offset_2;
    uint32_t reserved;
} __packed;

struct idt_pointer {
    uint16_t limit;
    uintptr_t base;
} __packed;

struct intr_handler {
    void *data;
    intr_handler_t func;
};

static struct idt_entry idt[IDT_SIZE] = { 0 };
static struct idt_pointer idt_ptr = { 0 };
static struct intr_handler handlers[IDT_SIZE] = { 0 };

/* Generated by a shell script */
extern const uintptr_t __intr_stubs[IDT_SIZE];

static void set_entry(unsigned int vector, uint16_t selector, uintptr_t offset, uint8_t flags)
{
    struct idt_entry entry = { 0 };
    entry.offset_0 = offset & 0xFFFF;
    entry.offset_1 = (offset >> 16) & 0xFFFF;
    entry.offset_2 = (offset >> 32) & 0xFFFFFFFF;
    entry.selector = selector;
    entry.flags = flags | IDT_PRESENT;
    memcpy(idt + vector, &entry, sizeof(entry));
}

void __used __intr_handler(struct intr_frame *frame)
{
    frame->vector &= 0xFF;
    if(!handlers[frame->vector].func)
        return;
    handlers[frame->vector].func(frame, handlers[frame->vector].data);
}

cpu_flags_t enable_intrs(void)
{
    cpu_flags_t flags = get_cpu_flags();
    asm volatile("cli");
    return flags;
}

cpu_flags_t disable_intrs(void)
{
    cpu_flags_t flags = get_cpu_flags();
    asm volatile("sti");
    return flags;
}

void set_intr(unsigned int intr, intr_handler_t fn, void *arg)
{
    intr &= 0xFF;
    handlers[intr].data = arg;
    handlers[intr].func = fn;
}

static int init_intr(void)
{
    uint8_t flags;
    unsigned int i;


    for(i = 0; i < IDT_SIZE; i++) {
        flags = 0;

        /* For now we only allow ring 0 to trigger anything */
        flags |= IDT_RING_0;

        /* Guess the gate type by index */
        flags |= (i == 0 || i == 1 || (i >= 3 && i <= 31))
            ? IDT_TRAP
            : IDT_INTR;

        set_entry(i, SEG_SELECTOR(SEG_INDEX_KERN_CODE_64, 0, 0), __intr_stubs[i], flags);
    }

    idt_ptr.limit = (uint16_t)(sizeof(idt) - 1);
    idt_ptr.base = (uintptr_t)(&idt[0]);

    asm volatile("lidtq %0"::"m"(idt_ptr));
    kp_inform("idt: limit=%hu, base=%p", idt_ptr.limit, (void *)idt_ptr.base);

    return 0;
}
initcall_tier_0(intr, init_intr);
initcall_dependency(intr, segment);
