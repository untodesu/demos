/* SPDX-License-Identifier: BSD-2-Clause */
#include <sys/intr.h>
#include <sys/printk.h>
#include <sys/seg.h>
#include <sys/string.h>

#define IDT_SIZE 256

#define IDT_TRAP    (15 << 0)
#define IDT_INTR    (14 << 0)
#define IDT_RING_0  ( 0 << 5)
#define IDT_RING_3  ( 3 << 5)
#define IDT_PRESENT ( 1 << 7)

struct idt_entry {
    uint16_t offset_0;
    uint16_t selector;
    uint8_t ist_off;
    uint8_t flags;
    uint16_t offset_1;
    uint32_t offset_2;
    uint32_t reserved;
} __packed;

struct idt_pointer {
    uint16_t limit;
    uintptr_t base;
} __packed;

struct interrupt_handler {
    void *data;
    interrupt_t func;
};

static struct idt_entry idt[IDT_SIZE] = { 0 };
static struct idt_pointer idt_ptr = { 0 };
static struct interrupt_handler handlers[IDT_SIZE] = { 0 };

/* Generated by a shell script */
extern const uintptr_t interrupt_stubs[IDT_SIZE];

static void set_entry(unsigned int vector, uint16_t selector, uintptr_t offset, uint8_t flags)
{
    struct idt_entry entry = { 0 };
    entry.offset_0 = offset & 0xFFFF;
    entry.offset_1 = (offset >> 16) & 0xFFFF;
    entry.offset_2 = (offset >> 32) & 0xFFFFFFFF;
    entry.selector = selector;
    entry.flags = flags | IDT_PRESENT;
    memcpy(idt + vector, &entry, sizeof(entry));
}

void __used interrupt_handler(struct interrupt_frame *frame)
{
    frame->vector &= 0xFF;
    if(!handlers[frame->vector].func)
        return;
    handlers[frame->vector].func(frame, handlers[frame->vector].data);
}

void set_interrupt_handler(unsigned int vector, interrupt_t func, void *data)
{
    vector &= 0xFF;
    handlers[vector].data = data;
    handlers[vector].func = func;
}

static int init_interrupts(void)
{
    uint8_t flags;
    unsigned int i;


    for(i = 0; i < IDT_SIZE; i++) {
        flags = 0;

        /* For now we only allow ring 0 to trigger anything */
        flags |= IDT_RING_0;

        /* Guess the gate type by index */
        flags |= (i == 0 || i == 1 || (i >= 3 && i <= 31)) ? IDT_TRAP : IDT_INTR;

        set_entry(i, SEG_SELECTOR(SEG_INDEX_KERN_CODE, 0, 0), interrupt_stubs[i], flags);
    }

    idt_ptr.limit = (uint16_t)(sizeof(idt) - 1);
    idt_ptr.base = (uintptr_t)(&idt[0]);

    printk(LOGLEVEL_INFO, "idt: limit=%hu, base=%p", idt_ptr.limit, (void *)idt_ptr.base);

    asm volatile("lidtq %0"::"m"(idt_ptr));

    return 0;
}

boot_initcall(interrupts, init_interrupts);
initcall_dependency(interrupts, segment);
